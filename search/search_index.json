{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AWS Integrated Application Test Kit Overview","text":"<p>Integrated Application Test Kit is in Public Preview</p> <p>AWS Integrated Application Test Kit (AWS IATK) is a framework that developers can use to write integration tests to run against their event-driven applications in the AWS Cloud. AWS IATK simplifies the writing of integration tests for serverless applications by doing the following:</p> <ul> <li>Providing utilities that generate test events to trigger an application.</li> <li>Validating event flow and structure in Amazon EventBridge.</li> <li>Asserting event flow against AWS X-Ray traces. </li> </ul>"},{"location":"#install","title":"Install","text":"<p>You can install AWS IATK for Python using one of the following options:</p> <p>Pip: <pre><code>pip install aws-iatk\n</code></pre></p> <p>Looking for Pip signed releases? Learn more about verifying signed builds</p>"},{"location":"#set-up","title":"Set up","text":""},{"location":"#credentials-configurations","title":"Credentials Configurations","text":"<p>AWS IATK requires AWS credentials in order to interact with the AWS resources in your account. You can specify this in <code>AwsIatk</code> directly, as shown below. You can also set Environment Variables instead.</p> <pre><code>from aws_iatk import AwsIatk\n\niatk = AwsIatk(\n    profile=PROFILE,\n    region=REGION\n)\n</code></pre>"},{"location":"#environment-variables","title":"Environment variables","text":"Info <p>Explicit parameters take precedence over environment variables</p> Enviromment Variable Description AWS_REGION AWS Region to use AWS_ACCESS_KEY_ID AWS Access Key to use AWS_SECRET_ACCESS_KEY AWS Secret Access Key to use AWS_SESSION_TOKEN AWS Session Token to use (optional)"},{"location":"#quick-getting-started","title":"Quick getting started","text":"<p>To start using AWS IATK, see Tutorial.</p>"},{"location":"#concepts","title":"Concepts","text":""},{"location":"#system-under-test-sut","title":"System Under Test (SUT)","text":"<p>The system being tested for correct operations (including happy and error paths).</p>"},{"location":"#test-harness","title":"Test Harness","text":"<p>A group of AWS resources AWS IATK creates for the purpose of facilitating testing around an integration. These resources are intended to exist only for the duration of the test run, and should be destroyed after the test run completes.</p>"},{"location":"#arrange-act-assert-testing-pattern","title":"Arrange, Act, Assert Testing Pattern","text":"<p>AWS IATK enables testing done through the Arrange, Act, Assert testing pattern. AWS IATK will help setup and retrieve deployed resources (Arrange). Then, AWS IATK gives you the information in order to Assert on those resources.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#overview","title":"Overview","text":"<p>This project has adopted the Amazon Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opensource-codeofconduct@amazon.com with any additional questions or comments.</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#overview","title":"Overview","text":"<p>We continuously check and evolve our practices, therefore it is possible some diagrams may be eventually consistent.</p>"},{"location":"security/#verifying-signed-builds","title":"Verifying signed builds","text":""},{"location":"security/#terminology","title":"Terminology","text":"<p>We use SLSA to ensure our builds are reproducible and to adhere to supply chain security practices.</p> <p>Within our releases page, you will notice a new metadata file: <code>multiple.intoto.jsonl</code>. It's metadata to describe where, when, and how our build artifacts were produced - or simply, attestation in SLSA terminology.</p> <p>For this to be useful, we need a verification tool - SLSA Verifier. SLSA Verifier decodes attestation to confirm the authenticity, identity, and the steps we took in our release pipeline (e.g., inputs, git commit/branch, GitHub org/repo, build SHA256, etc.).</p>"},{"location":"security/#how-to","title":"HOW TO","text":"<ul> <li>Download SLSA Verifier binary</li> <li>Download the latest release artifact from PyPi (either wheel or tar.gz )</li> <li>Download <code>python-client.multiple.intoto.jsonl</code> attestation from the latest release under Assets</li> </ul> <p>Next steps assume macOS on Apple Silicon as the operating system, and release v0.1.0</p> <p>You should have the following files in the current directory:</p> <ul> <li>SLSA Verifier tool: <code>slsa-verifier-darwin-arm64</code></li> <li>IATK Python Client Release artifact: <code>aws-iatk-0.1.0.tar.gz</code></li> <li>IATK Python Client attestation: <code>python-client.multiple.intoto.jsonl</code></li> </ul> <p>You can now run SLSA Verifier with the following options:</p> <pre><code>./slsa-verifier-darwin-arm64 verify-artifact \\\n    --provenance-path \"python-client.multiple.intoto.jsonl\" \\\n    --source-uri github.com/awslabs/aws-iatk \\\n    aws-iatk-0.1.0.tar.gz\n</code></pre>"},{"location":"contributing/conventions/","title":"GoLang Conventions","text":"<p>We follow Effictive Go</p>"},{"location":"contributing/conventions/#python-conventions","title":"Python Conventions","text":"<p>PEP8 conventions are used</p>"},{"location":"contributing/getting_started/","title":"Your first contribution","text":"<p>Great you want to contribute to AWS Integrated Application Test Kit (AWS IATK)!</p> <p>Before moving forward, see Conventions to learn about our coding practices, coding style, and package setup.</p>"},{"location":"contributing/getting_started/#overview","title":"Overview","text":"<p>AWS IATK is built as a mono repo, in which we have both a RPC binary (the Golang code) and the \"language client\" (currently Python). </p> <p>Everything under <code>python-client</code> is the Python related code. We embed the Go binary into this at release but locally you can build the binary and install the Python Client as needed.</p> <p>Typically, changes will be focused within the Go code. This holds the code that powers AWS IATK and provides easy language expansion.</p>"},{"location":"contributing/getting_started/#how-to-contribute","title":"How to contribute","text":"<p>We accept all contributions, such as documentation updates, code refactors, and new features. However, the maintainers (AWS) reserve the right to reject contributions that don't fit our long term vision, are complicated to maintain, or other reasons. We will do our best to communicate why something is not accepted. To reduce churn, we ask that your contributions start from a GitHub issue. Simple tasks, like grammar, fixing language in docs, etc do not require a GitHub issue. If the issue needs alignment with the team (e.g feature or bug), we will close the PR and ask for a GitHub Issue. This is to reduce time and wasted effort fixing or adding something we might not accept. You can find issues to work on by looking at <code>stage/accepted</code> labels that are not assigned. This indicates that the issue was reviewed by the team and ready for anyone to pickup (team member or community).</p> <p>Once you have an issue, make changes as needed. We encourage the community to submit Draft PRs which can allow a maintainer to help in the event you are stuck.</p> <p>Once changes are ready, either submit the PR or move the open PR out of draft. A maintainer will then review the code and provide targeted feedback. </p> <p>Once a maintainer or maintainers approve, the PR will be merged and slotted for a release. We do not communicate releases ahead of time, as there are external factors to a release that cannot be accounted for. We will do our best to ship updates regularly to ensure fixes and features land in customers hands.</p>"},{"location":"contributing/setup/","title":"Development environment","text":""},{"location":"contributing/setup/#prerequisites","title":"Prerequisites","text":"<p>First ensure you have Go 1.20+ and Python 3.8+ installed. Note: you only need python installed if you are editing the python code under <code>python-client</code> directory. You will also need to clone the repo.</p>"},{"location":"contributing/setup/#package-setup","title":"Package setup","text":"<p>The codebase is split into to chunks: a JSON RPC and Python client. The Python client is isolated to <code>python-client</code> directory.</p>"},{"location":"contributing/setup/#go-rpc","title":"Go RPC","text":"<p>Assuming you have installed Go, navigate to the root of the repo.</p> <p>You can build the Go binary by running <code>make build</code>. <code>make lint</code> will run <code>golangci-lint</code> to lint the code. You can run all the unit tests through <code>make test</code> or <code>make dev-test</code>. </p> <p>Before committing and submitting a PR, please run the following:</p> <ol> <li><code>make dev-test</code></li> <li><code>make integ-test</code></li> </ol>"},{"location":"contributing/setup/#python-client","title":"Python Client","text":"<p>Navigate to <code>python-client</code>. Make changes as needed.</p> <p>Before committing and submitting a PR, please run the following:</p> <ol> <li><code>make build-iatk-service</code></li> <li><code>make init</code></li> <li><code>make unit-test</code></li> <li><code>make contract-test</code></li> </ol>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial introduces AWS Integrated Application Test Kit (AWS IATK) by going through four examples. Each of them showcases one feature at a time.</p> <p>For each example, we will execute the following steps:</p> <ol> <li>Deploy System Under Test (SUT) with AWS SAM CLI or AWS CDK.</li> <li>Run the example test code with pytest.</li> </ol>"},{"location":"tutorial/#terminologies","title":"Terminologies","text":"<p>Here are some terminologies we will use throughout the examples:</p> <ul> <li>System Under Test (SUT) - the system being tested for correct operations (including happy and error paths)</li> <li>Test Harness - Test Harness is a group of AWS resources AWS IATK creates for the purpose of facilitating testing around an integration. These resources are intended to exist only for the duration of the test run, and should be destroyed after the test run completes.</li> </ul>"},{"location":"tutorial/#requirements","title":"Requirements","text":"<ul> <li>AWS CLI and configured with your credentials.</li> <li>AWS SAM CLI installed.</li> <li>AWS CDK installed.</li> <li>Python 3.8+ installed.</li> </ul>"},{"location":"tutorial/#getting-started","title":"Getting started","text":"<p>Clone the examples:</p> <pre><code>git clone --single-branch --branch examples git@github.com:awslabs/aws-iatk.git iatk-examples\ncd iatk-examples\n</code></pre> <p>To run the Python (3.8+) examples:</p> <pre><code>python -m venv. venv\nsource .venv/bin/activate\n\npip install -r requirements.txt\n</code></pre>"},{"location":"tutorial/examples/eb_testing/","title":"Testing EventBridge Event Bus with \"Listener\"","text":"<p>In this example, we use a \"Listener\" to test a rule on an Amazon EventBridge event bus. A \"Listener\" is a \"Test Harness\" that AWS IATK helps you create for testing event delivery.</p>"},{"location":"tutorial/examples/eb_testing/#system-under-test","title":"System Under Test","text":"<p>For this example, we use AWS CDK to define the System Under Test (SUT). The SUT consists of these resources:</p> <ul> <li>An Amazon API Gateway REST API (Entry Point).</li> <li>An AWS Lambda function (Producer).</li> <li>An EventBridge event bus.</li> <li>An EventBridge rule.</li> <li>A Lambda function (Consumer), as a target of the rule.</li> </ul> <p>When the REST API receives a request, it invokes the producer. The producer then sends an event to the event bus, which then delivers the event to the consumer according to the rule.</p> <p>We added some <code>CfnOutput</code> constructs to expose certain attributes from the System Under Test (SUT). These include:</p> <ul> <li>The name of the event bus.</li> <li>The URL of the API endpoint.</li> <li>The EventBridge rule name.</li> <li>The target ID in the rule.</li> </ul> <p>These values will be used during the tests.</p> 02-eb_listener/cdk/lib/eb-stack.ts <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { Construct } from 'constructs';\nimport * as apigateway from 'aws-cdk-lib/aws-apigateway';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as events from 'aws-cdk-lib/aws-events';\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\nimport * as path from 'path';\n\nexport class EbStack extends cdk.Stack {\n    eventbus: events.EventBus | null = null;\n    rule: events.Rule | null = null;\n    target: targets.LambdaFunction | null = null;\n    api: apigateway.RestApi | null = null;\n\n    constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n        super(scope, id, props);\n\n        this.eventbus = new events.EventBus(this, 'EB');\n\n        const producer = new lambda.Function(this, 'Producer', {\n            code: lambda.Code.fromAsset(path.resolve('..', 'dist', 'producerHandler')),\n            runtime: lambda.Runtime.NODEJS_18_X,\n            handler: 'index.lambdaHandler',\n            environment: {\n                EVENTBUS_NAME: this.eventbus.eventBusName,\n            },\n            tracing: lambda.Tracing.ACTIVE,\n        });\n        this.eventbus.grantPutEventsTo(producer);\n\n        this.api = new apigateway.RestApi(this, 'API', {\n            deploy: true,\n            deployOptions: {\n                tracingEnabled: true,\n            },\n        });\n        const resource = this.api.root.addResource('orders');\n        const integration = new apigateway.LambdaIntegration(producer, {\n            proxy: true,\n        });\n        resource.addMethod('POST', integration);\n\n        const consumer = new lambda.Function(this, 'Consumer', {\n            code: lambda.Code.fromAsset(path.resolve('..', 'dist', 'consumerHandler')),\n            runtime: lambda.Runtime.NODEJS_18_X,\n            handler: 'index.lambdaHandler',\n            environment: {\n                EVENTBUS_NAME: this.eventbus.eventBusName,\n            },\n            tracing: lambda.Tracing.ACTIVE,\n        });\n\n        this.rule = new events.Rule(this, 'ConsumerRule', {\n            eventBus: this.eventbus,\n            eventPattern: {\n                source: ['com.hello-world.producer'],\n                detailType: ['NewOrder'],\n            },\n        });\n        this.target = new targets.LambdaFunction(consumer, {\n            event: events.RuleTargetInput.fromEventPath('$.detail.customerId'),\n        });\n        this.rule.addTarget(this.target);\n\n        this.output();\n    }\n\n    output() {\n        if (this.eventbus) {\n            new cdk.CfnOutput(this, 'EventBusName', {\n                description: 'Event Bus Name',\n                value: this.eventbus.eventBusName,\n            });\n        }\n\n        if (this.rule) {\n            new cdk.CfnOutput(this, 'RuleName', {\n                description: 'Rule Name',\n                value: this.rule.ruleName,\n            });\n            new cdk.CfnOutput(this, 'TargetId', {\n                description: 'Target Id',\n                value: 'Target0',\n            });\n        }\n        if (this.api) {\n            new cdk.CfnOutput(this, 'ApiEndpoint', {\n                description: 'API Endpoint',\n                value: this.api.urlForPath('/orders'),\n            });\n        }\n    }\n}\n</code></pre> <p>To deploy the SUT:</p> <pre><code># navigate to the example dir\ncd \"02-eb_listener\"\n\n# install dependencies for building and deploying\nnpm install\n\n# Deploy the stack using cdk, see package.json for definition of the command:\nnpm run deploy\n</code></pre> <p>After deploying, the output file <code>outputs.json</code> is created, with contents similar to below:</p> outputs.json <pre><code>{\n    \"example-ebStack\": {\n        \"EventBusName\": \"examplestack01EB321ED36B\",\n        \"ApiEndpoint\": \"https://xxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/orders\",\n        \"APIEndpoint1793E782\": \"https://xxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/\",\n        \"RuleName\": \"examplestack01EB321ED36B|example-stack-01-ConsumerRuleEE1F6314-12K2NOJQRM8A6\",\n        \"TargetId\": \"Target0\"\n    }\n}\n</code></pre>"},{"location":"tutorial/examples/eb_testing/#test-code","title":"Test Code","text":""},{"location":"tutorial/examples/eb_testing/#python","title":"Python","text":"<p>In the test code, we follow the \"Arrage, Act, Assert\" pattern. In Python, we do this by using <code>unittest.TestCase</code>. We use <code>setUpClass</code> and <code>tearDownClass</code> to create and destroy Test Harnesses before and after individual tests respectively. Specifically:</p> <ul> <li>In <code>setUpClass</code>, we first call <code>remove_listeners</code> with <code>tag_filters</code> to shut down any previous orphaned listener. Then we call <code>add_listener</code> to create a listener by providing the event bus name, the rule name, and the target ID. Those values are retrieved from the \"outputs.json\" file. We also attach a tag to the listener so we can look it up more easily. The <code>add_listener</code> returns the listener ID. We keep the listener ID throughout the tests.</li> <li>In <code>tearDownClass</code>, we call <code>remove_listeners</code> to shut down the listener created during <code>setUpClass</code>.</li> </ul> <p>We have two tests, <code>test_event_lands_at_eb</code> and <code>test_poll_events</code>, which showcase the <code>wait_until_event_matched</code> method and the <code>poll_events</code> method respectively:</p> <ul> <li>In <code>test_event_lands_at_eb</code>, we define a function <code>assert_fn</code> to determine if a received event is matching expectation. We supply <code>assert_fn</code> to the <code>wait_until_event_matched</code> method as an argument. The method will keep polling events from the listener until the given <code>assert_fn</code> succeeds or until timeout.</li> <li>In <code>test_poll_events</code>, we call the <code>poll_events</code> method. This method is a primitive method of <code>wait_until_event_matched</code>, i.e. it polls from the listener just once.</li> </ul> 02-eb_listener/tests/python/test_example_02.py <pre><code>import logging\nimport json\nimport pathlib\nfrom unittest import TestCase\n\nimport requests\nimport aws_iatk\n\n\nLOG = logging.getLogger(__name__)\nLOG.setLevel(logging.DEBUG)\n\n\ndef read_cdk_outputs() -&gt; dict:\n    with open(pathlib.Path(__file__).parent.parent.parent / \"outputs.json\") as f:\n        outputs = json.load(f)\n    return outputs\n\nclass Example02(TestCase):\n    stack_name: str = \"cdk-example-ebStack\"\n    stack_outputs: dict = read_cdk_outputs().get(stack_name, {}) \n    iatk: aws_iatk.AwsIatk = aws_iatk.AwsIatk()\n\n    @classmethod\n    def setUpClass(cls) -&gt; None:\n        cls.event_bus_name = cls.stack_outputs[\"EventBusName\"]\n        cls.api_endpoint = cls.stack_outputs[\"ApiEndpoint\"]\n        cls.rule_name = cls.stack_outputs[\"RuleName\"].split(\"|\")[1]\n        cls.target_id = cls.stack_outputs[\"TargetId\"]\n\n        # remote orphaned listeners from previous test runs (if any)\n        cls.iatk.remove_listeners(\n            tag_filters=[\n                aws_iatk.RemoveListeners_TagFilter(\n                    key=\"stage\",\n                    values=[\"example02\"],\n                )\n            ]\n        )\n\n        # create listener\n        listener_id = cls.iatk.add_listener(\n            event_bus_name=cls.event_bus_name,\n            rule_name=cls.rule_name,\n            target_id=cls.target_id,\n            tags={\"stage\": \"example02\"},\n        ).id\n        cls.listeners = [listener_id]\n        LOG.debug(\"created listeners: %s\", cls.listeners)\n        super().setUpClass()\n\n    @classmethod\n    def tearDownClass(cls) -&gt; None:\n        cls.z.remove_listeners(\n            ids=cls.listeners,\n        )\n        LOG.debug(\"destroyed listeners: %s\", cls.listeners)\n        super().tearDownClass()\n\n    def test_event_lands_at_eb(self):\n        customer_id = \"abc123\"\n        requests.post(self.api_endpoint, params={\"customerId\": customer_id})\n\n        def assert_fn(received: str) -&gt; None:\n            received = json.loads(received)\n            LOG.debug(\"received: %s\", received)\n            assert received == customer_id\n\n        self.assertTrue(\n            self.iatk.wait_until_event_matched(\n                listener_id=self.listeners[0],\n                assertion_fn=assert_fn,\n            )\n        )\n\n    def test_poll_events(self):\n        customer_id = \"def456\"\n        requests.post(self.api_endpoint, params={\"customerId\": customer_id})\n\n        received = self.iatk.poll_events(\n            listener_id=self.listeners[0],\n            wait_time_seconds=5,\n            max_number_of_messages=10,\n        ).events\n        LOG.debug(\"received: %s\", received)\n        self.assertGreaterEqual(len(received), 1)\n        self.assertEqual(json.loads(received[0]), customer_id)\n</code></pre> <p>To run the test code:</p> <pre><code>pytest tests/python/test_example_02.py\n</code></pre>"},{"location":"tutorial/examples/generate_mock_events/","title":"Generate mock events","text":"<p>AWS Integrated Application Test Kit (AWS IATK) provides the capability for you to generate mock events from a schema stored in the Amazon EventBridge schema registry. This allows you to generate a mock event and invoke any consumer (such as an AWS Lambda function or AWS Step Functions state machine) with the generated event.</p>"},{"location":"tutorial/examples/generate_mock_events/#system-under-test-sut","title":"System Under Test (SUT)","text":"<p>In this example, we use AWS CDK to define the SUT. The SUT consists of one schema registry, one schema and one Lambda function.</p> <p>We added some <code>CfnOutput</code> constructs to expose certain attributes from the SUT. These include:</p> <ul> <li>The name of the Lambda function.</li> <li>The name of the schema registry.</li> <li>The name of the schema.</li> </ul> <p>These values will be used during the tests.</p> 04-event_generation/cdk/lib/schema-stack.ts <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { Construct } from 'constructs';\nimport * as eventschemas from 'aws-cdk-lib/aws-eventschemas';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as path from 'path';\n\nexport class SchemaStack extends cdk.Stack {\n    registry: eventschemas.CfnRegistry | null = null;\n    schema: eventschemas.CfnSchema | null = null;\n    lambdaFunction: lambda.Function | null = null;\n\n    constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n        super(scope, id, props);\n\n        this.registry = new eventschemas.CfnRegistry(this, 'MyRegistry', {});\n        this.schema = new eventschemas.CfnSchema(this, 'MySchema', {\n            registryName: this.registry.attrRegistryName,\n            type: 'OpenApi3',\n            content: JSON.stringify({\n                openapi: '3.0.0',\n                info: {\n                    version: '1.0.0',\n                    title: 'my-event',\n                },\n                paths: {},\n                components: {\n                    schemas: {\n                        MyEvent: {\n                            type: 'object',\n                            properties: {\n                                customerId: {\n                                    type: 'string',\n                                },\n                                datetime: {\n                                    type: 'string',\n                                    format: 'date-time',\n                                },\n                                membershipType: {\n                                    type: 'string',\n                                    enum: ['A', 'B', 'C'],\n                                },\n                                address: {\n                                    type: 'string',\n                                },\n                                orderItems: {\n                                    type: 'array',\n                                    items: {\n                                        $ref: '#/components/schemas/Item',\n                                    },\n                                },\n                            },\n                        },\n                        Item: {\n                            type: 'object',\n                            properties: {\n                                sku: {\n                                    type: 'string',\n                                },\n                                unitPrice: {\n                                    type: 'number',\n                                },\n                                count: {\n                                    type: 'integer',\n                                },\n                            },\n                        },\n                    },\n                },\n            }),\n        });\n\n        this.lambdaFunction = new lambda.Function(this, 'Calculator', {\n            code: lambda.Code.fromAsset(path.resolve('..', 'dist', 'calculatorHandler')),\n            runtime: lambda.Runtime.NODEJS_18_X,\n            handler: 'index.lambdaHandler',\n        });\n\n        // outputs\n        new cdk.CfnOutput(this, 'CalculatorFunction', {\n            description: 'Lambda Function Name',\n            value: this.lambdaFunction.functionName,\n        });\n        new cdk.CfnOutput(this, 'RegistryName', {\n            value: this.registry.attrRegistryName,\n        });\n        new cdk.CfnOutput(this, 'SchemaName', {\n            value: this.schema.attrSchemaName,\n        });\n    }\n}\n</code></pre> <p>To deploy the SUT:</p> <pre><code># navigate to the example dir\ncd \"04-event_generation\"\n\n# install dependencies for building and deploying\nnpm install\n\n# Deploy the stack using cdk, see package.json for definition of the command:\nnpm run deploy\n</code></pre> <p>After deploying, an output file <code>outputs.json</code> is created, with contents similar to below:</p> outputs.json <pre><code>{\n  \"example-schemaStack\": {\n    \"CalculatorFunction\": \"cdk-example-schemaStack-CalculatorBxxxxF40-5SYJsAlTscGC\",\n    \"RegistryName\": \"MyRegsitry-xx5rNdAMGJL1\",\n    \"SchemaName\": \"MySchema-xxKd3I1NbYAu\"\n  }\n}\n</code></pre>"},{"location":"tutorial/examples/generate_mock_events/#test-code","title":"Test Code","text":""},{"location":"tutorial/examples/generate_mock_events/#python","title":"Python","text":"<p>This test uses three testse, <code>test_generate_barebone_event</code>, <code>test_generate_contextful_event</code> and <code>test_generate_eventbridge_event</code>, to demostrate how you can generate mock events:</p> <p>In <code>test_generate_barebone_event</code>, we call <code>generate_mock_event</code> by providing only <code>registry_name</code>, <code>schema_name</code> and <code>event_ref</code>. This gives you a \"barebone\" event:</p> <pre><code>{\n  \"address\": \"\",\n  \"customerId\": \"\",\n  \"datetime\": \"2023-10-18T21:08:04.782196-07:00\",\n  \"membershipType\": \"A\",\n  \"orderItems\": []\n}\n</code></pre> <p>As shown in <code>test_generate_contextful_event</code>, you can supply contexts to enrich the generated event. We defined a function <code>apply_context</code> which populates the <code>customerId</code> field and the <code>address</code> field. Also, we add five items into <code>orderItems</code>. We then supply this function into the <code>contexts</code> argument in the <code>generate_mock_event</code> call. Note that <code>contexts</code> accepts a list of functions, meaning that you can apply multiple contexts. The generated events looks like:</p> <pre><code>{\n  \"address\": \"99 Some Street\",\n  \"customerId\": \"8e9bf525-168c-47ad-96e6-507dd4a15ba5\",\n  \"datetime\": \"2023-10-18T21:08:05.31715-07:00\",\n  \"membershipType\": \"A\",\n  \"orderItems\": [\n    {\n      \"unitPrice\": 2,\n      \"count\": 1\n    },\n    {\n      \"unitPrice\": 4,\n      \"count\": 2\n    },\n    {\n      \"unitPrice\": 6,\n      \"count\": 3\n    },\n    {\n      \"unitPrice\": 8,\n      \"count\": 4\n    },\n    {\n      \"unitPrice\": 10,\n      \"count\": 5\n    }\n  ]\n}\n</code></pre> <p>In the same test, we then use the generated event as payload to invoke the Lambda function, and assert if the return from the invocation equals the expected value.</p> <p>As shown in <code>test_generate_eventbridge_event</code>, if you are generating EventBridge events, AWS IATK provides <code>aws_iatk.context_generation.eventbridge_event_context</code> for you to enrich a barebone EventBridge event.</p> 04-event_generation/tests/python/test_example_04.py <pre><code>import logging\nimport json\nimport pathlib\nimport uuid\n\nimport boto3\nimport aws_iatk\nfrom aws_iatk.context_generation import eventbridge_event_context\n\nLOG = logging.getLogger(__name__)\nLOG.setLevel(logging.DEBUG)\nlambda_client = boto3.client(\"lambda\")\n\ndef read_cdk_outputs() -&gt; dict:\n    with open(pathlib.Path(__file__).parent.parent.parent / \"outputs.json\") as f:\n        outputs = json.load(f)\n    return outputs\n\ndef test_generate_barebone_event():\n    stack_name = \"cdk-example-schemaStack\"\n    stack_outputs = read_cdk_outputs().get(stack_name, {})\n    registry_name = stack_outputs[\"RegistryName\"]\n    schema_name = stack_outputs[\"SchemaName\"]\n    iatk = aws_iatk.AwsIatk()\n    barebone_event = iatk.generate_mock_event(\n        registry_name=registry_name,\n        schema_name=schema_name,\n        event_ref=\"MyEvent\",\n    ).event\n    LOG.debug(json.dumps(barebone_event, indent=2))\n    for key in [\"address\", \"customerId\", \"datetime\", \"membershipType\", \"orderItems\"]:\n        assert key in barebone_event\n    assert barebone_event[\"address\"] == \"\"\n    assert barebone_event[\"customerId\"] == \"\"\n    assert barebone_event[\"orderItems\"] == []\n\ndef test_generate_contextful_event():\n    stack_name = \"cdk-example-schemaStack\"\n    stack_outputs = read_cdk_outputs().get(stack_name, {})\n    registry_name = stack_outputs[\"RegistryName\"]\n    schema_name = stack_outputs[\"SchemaName\"]\n    function_name = stack_outputs[\"CalculatorFunction\"]\n    iatk = aws_iatk.AwsIatk()\n\n    def apply_context(event: dict) -&gt; dict:\n        event[\"customerId\"] = str(uuid.uuid4())\n        event[\"address\"] = \"99 Some Street\"\n        for i in range(5):\n            item = {\n                \"unitPrice\": (i + 1) * 2,\n                \"count\": i + 1, \n            }\n            event[\"orderItems\"].append(item)\n        return event\n\n    mock_event = iatk.generate_mock_event(\n        registry_name=registry_name,\n        schema_name=schema_name,\n        event_ref=\"MyEvent\",\n        contexts=[apply_context],\n    ).event\n    LOG.debug(json.dumps(mock_event, indent=2))\n    for key in [\"address\", \"customerId\", \"datetime\", \"membershipType\", \"orderItems\"]:\n        assert key in mock_event\n    assert mock_event[\"customerId\"] != \"\"\n    assert mock_event[\"address\"] == \"99 Some Street\"\n    assert len(mock_event[\"orderItems\"]) &gt; 0\n\n    response = lambda_client.invoke(\n        FunctionName=function_name,\n        Payload=bytes(json.dumps(mock_event), encoding=\"utf-8\"),\n    )\n    result = int(response['Payload'].read())\n    assert result == 110\n\ndef test_generate_eventbridge_event():\n    iatk = aws_iatk.AwsIatk()\n\n    mock_eb_event = iatk.generate_mock_event(\n        registry_name=\"aws.events\",\n        schema_name=\"aws.autoscaling@EC2InstanceLaunchSuccessful\",\n        schema_version=\"2\",\n        event_ref=\"AWSEvent\",\n        contexts=[eventbridge_event_context],\n    ).event\n    LOG.debug(json.dumps(mock_eb_event, indent=2))\n    for key in [\"detail-type\", \"resources\", \"id\", \"source\", \"time\", \"detail\", \"region\", \"version\", \"account\"]:\n        assert key in mock_eb_event\n    assert mock_eb_event[\"id\"] != \"\"\n    assert mock_eb_event[\"account\"] != \"\"\n    assert mock_eb_event[\"time\"] != \"\"\n</code></pre> <p>To run the test code:</p> <pre><code>pytest tests/python/test_example_04.py\n</code></pre>"},{"location":"tutorial/examples/retrieve_cfn_info/","title":"Retrieving information from a deployed CloudFormation Stack","text":"<p>This example shows how to use <code>get_stack_outputs</code> and <code>get_physical_id_from_stack</code> to retrieve information from a deployed AWS CloudFormation Stack. They are useful if you deploy your stack directly with a CloudFormation template.</p>"},{"location":"tutorial/examples/retrieve_cfn_info/#system-under-test","title":"System Under Test","text":"<p>We will use SAM CLI to deploy the SUT to CloudFormation. The SUT consists of one SQS Queue. After deploying the SUT, the Queue URL of the queue can be retrieved from both Physical ID and Outputs.</p> 01-cfn_utils/template.json <pre><code>{\n    \"AWSTemplateFormatVersion\": \"2010-09-09\",\n    \"Description\": \"simple SQS template\",\n    \"Resources\": {\n        \"SQSQueue\": {\n            \"Type\": \"AWS::SQS::Queue\"\n        }\n    },\n    \"Outputs\": {\n        \"QueueURL\": {\n            \"Description\": \"URL of newly created SQS Queue\",\n            \"Value\": {\n                \"Ref\": \"SQSQueue\"\n            }\n        },\n        \"QueueURLFromGetAtt\": {\n            \"Description\": \"Queue URL\",\n            \"Value\": {\n                \"Fn::GetAtt\": [\n                    \"SQSQueue\",\n                    \"QueueUrl\"\n                ]\n            }\n        },\n        \"QueueArn\": {\n            \"Description\": \"Queue ARN\",\n            \"Value\": {\n                \"Fn::GetAtt\": [\n                    \"SQSQueue\",\n                    \"Arn\"\n                ]\n            }\n        }\n    }\n}\n</code></pre> <p>To deploy the stack using AWS SAM CLI:</p> <pre><code>cd \"01-cfn_utils\"\n\nsam deploy --stack-name example-01 --template ./template.json\n</code></pre>"},{"location":"tutorial/examples/retrieve_cfn_info/#test-code","title":"Test Code","text":""},{"location":"tutorial/examples/retrieve_cfn_info/#python","title":"Python","text":"<p>In the test code, we use both <code>get_stack_outputs</code> and <code>get_physical_id_from_stack</code> to get the Queue URL, then assert the values returned from both methods are equal.</p> 01-cfn_utils/test_example_01.py <pre><code>import os\nimport aws_iatk\n\ndef test_iatk_utils():\n    stack_name = os.getenv(\"STACK_NAME\", \"example-01\")\n    region = os.getenv(\"AWS_REGION\", \"us-east-1\")\n    iatk = aws_iatk.AwsIatk(region=region)\n\n    outputs = iatk.get_stack_outputs(\n        stack_name=stack_name,\n        output_names=[\"QueueURL\"],\n    ).outputs\n\n    physical_id = iatk.get_physical_id_from_stack(\n        stack_name=stack_name,\n        logical_resource_id=\"SQSQueue\",\n    ).physical_id\n\n    assert physical_id == outputs[\"QueueURL\"]\n</code></pre> <p>To run the test code:</p> <pre><code>pytest test_example_01.py\n</code></pre>"},{"location":"tutorial/examples/xray_testing/","title":"Testing with X-Ray traces","text":"<p>This example shows how to test with AWS X-Ray traces. When implemented throughout your application, X-Ray traces provides a good amount of detail that you can inspect for testing purposes. AWS IATK helps you fetch traces and parse them into objects that can easily be queried for inspection. For example, you can easily verify if a trace hits an expected sequence of AWS resources.</p>"},{"location":"tutorial/examples/xray_testing/#system-under-test-sut","title":"System Under Test (SUT)","text":"<p>In this example, we use AWS CDK to define the SUT. The SUT consists of one AWS Step Functions State Machine.</p> <p>We added some <code>CfnOutput</code> constructs to expose certain attributes from the SUT. These include:</p> <ul> <li>The name of the state machine.</li> <li>The ARN of the state machine.</li> </ul> <p>These values will be used during the tests.</p> 03-xray_trace_tree/cdk/lib/sfn-stack.ts <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { Construct } from 'constructs';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as sfn from 'aws-cdk-lib/aws-stepfunctions';\nimport * as tasks from 'aws-cdk-lib/aws-stepfunctions-tasks';\nimport * as sns from 'aws-cdk-lib/aws-sns';\n\nexport class SfnStack extends cdk.Stack {\n    statemachine: sfn.StateMachine | null = null;\n\n    constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n        super(scope, id, props);\n\n        const convertToSeconds = new tasks.EvaluateExpression(this, 'Convert to seconds', {\n            expression: '$.waitMilliseconds / 1000',\n            resultPath: '$.waitSeconds',\n        });\n\n        const createMessage = new tasks.EvaluateExpression(this, 'Create message', {\n            // Note: this is a string inside a string.\n            expression: '`Now waiting ${$.waitSeconds} seconds...`',\n            runtime: lambda.Runtime.NODEJS_LATEST,\n            resultPath: '$.message',\n        });\n\n        const publishMessage = new tasks.SnsPublish(this, 'Publish message', {\n            topic: new sns.Topic(this, 'cool-topic'),\n            message: sfn.TaskInput.fromJsonPathAt('$.message'),\n            resultPath: '$.sns',\n        });\n\n        const wait = new sfn.Wait(this, 'Wait', {\n            time: sfn.WaitTime.secondsPath('$.waitSeconds'),\n        });\n\n        const definition = convertToSeconds.next(createMessage).next(publishMessage).next(wait);\n        this.statemachine = new sfn.StateMachine(this, 'MyStateMachine', {\n            definitionBody: sfn.DefinitionBody.fromChainable(definition),\n            tracingEnabled: true,\n        });\n\n        new cdk.CfnOutput(this, 'StateMachineArn', {\n            description: 'State Machine ARN',\n            value: this.statemachine.stateMachineArn,\n        });\n        new cdk.CfnOutput(this, 'StateMachineName', {\n            description: 'State Machine Name',\n            value: this.statemachine.stateMachineName,\n        });\n    }\n}\n</code></pre> <p>To deploy the SUT:</p> <pre><code># navigate to the example dir\ncd \"03-xray_trace_tree\"\n\n# install dependencies for building and deploying\nnpm install\n\n# Deploy the stack using cdk, see package.json for definition of the command:\nnpm run deploy\n</code></pre> <p>After deploying, an output file <code>outputs.json</code> is created, with contents similar to below:</p> outputs.json <pre><code>{\n  \"example-sfnStack\": {\n    \"StateMachineArn\": \"arn:aws:states:us-east-1:123456789012:stateMachine:MyStateMachine6C968CA5-Ybusf26S5Oir\",\n    \"StateMachineName\": \"MyStateMachine6C968CA5-Ybusf26S5Oir\"\n  }\n}\n</code></pre>"},{"location":"tutorial/examples/xray_testing/#test-code","title":"Test Code","text":""},{"location":"tutorial/examples/xray_testing/#python","title":"Python","text":"<p>In the test code, we first implement the <code>setUp</code> method to start a state machine execution, and wait for the execution to complete. We keep the tracing header of the execution.</p> <p>We have two tests, <code>test_get_trace_tree</code> and <code>test_retry_get_trace_tree_until</code>, which showcase the <code>get_trace_tree</code> method and the <code>retry_get_trace_tree_until</code> method:</p> <ul> <li>In <code>test_get_trace_tree</code>, we added a sleep of 5 seconds to wait for the trace to be fetchable. The <code>get_trace_tree</code> uses the fetched trace to build and return a trace tree. Nodes of the tree are segments or subsegments of the trace. The root is the starting point of the trace. The method returns the root segment and also all the paths in the tree. Each path is a sequence of nodes from root to leaf. In the test, we extract the <code>origin</code> attribute of each node of each path to assert if the expected sequence of AWS resources were invoked. </li> <li>In <code>test_retry_get_trace_tree_until</code>, no sleep is needed as the <code>retry_get_trace_tree_until</code> method handles the latency issue by retrying fetching the trace with exponential backoff. In this test, we also define function called <code>condition</code> to do assertion on the returned Trace Tree. We supply <code>condition</code> to the <code>retry_get_trace_tree_until</code> as a stopping condition.</li> </ul> 03-xray_trace_tree/tests/python/test_example_03.py <pre><code>import logging\nimport json\nimport pathlib\nimport time\nfrom unittest import TestCase\n\nimport boto3\nimport aws_iatk\n\n\nLOG = logging.getLogger(__name__)\nLOG.setLevel(logging.DEBUG)\n\n\ndef read_cdk_outputs() -&gt; dict:\n    with open(pathlib.Path(__file__).parent.parent.parent / \"outputs.json\") as f:\n        outputs = json.load(f)\n    return outputs\n\nclass Example03(TestCase):\n    stack_name: str = \"cdk-example-sfnStack\"\n    stack_outputs: dict = read_cdk_outputs().get(stack_name, {}) \n    statemachine_arn: str = stack_outputs[\"StateMachineArn\"]\n    iatk: aws_iatk.AwsIatk = aws_iatk.AwsIatk()\n    # patch sfn client to ensure trace is sampled\n    sfn_client: boto3.client = iatk.patch_aws_client(boto3.client(\"stepfunctions\"))\n\n    def setUp(self):\n        self.tracing_header = None\n\n        response = self.sfn_client.start_execution(\n            stateMachineArn=self.statemachine_arn,\n            input=json.dumps({\"waitMilliseconds\": 1000}),\n        )\n        execution_arn = response[\"executionArn\"]\n        status = \"RUNNING\"\n        while status == \"RUNNING\":\n            res = self.sfn_client.describe_execution(\n                executionArn=execution_arn,\n            )\n            status = res[\"status\"]\n            if not self.tracing_header:\n                self.tracing_header = res[\"traceHeader\"]\n\n\n    def test_get_trace_tree(self):\n        time.sleep(5)\n        trace_tree = self.iatk.get_trace_tree(\n            tracing_header=self.tracing_header,\n        ).trace_tree\n\n        self.assertEqual(len(trace_tree.paths), 3)\n        self.assertEqual(\n            [[seg.origin for seg in path] for path in trace_tree.paths],\n            [\n                [\"AWS::StepFunctions::StateMachine\", \"AWS::Lambda\"],\n                [\"AWS::StepFunctions::StateMachine\", \"AWS::Lambda\"],\n                [\"AWS::StepFunctions::StateMachine\", \"AWS::SNS\"],\n            ]\n        )\n\n    def test_retry_get_trace_tree_until(self):\n        def assertion(output: aws_iatk.GetTraceTreeOutput) -&gt; None:\n            tree = output.trace_tree\n            self.assertEqual(len(tree.paths), 3)\n            self.assertEqual(\n                [[seg.origin for seg in path] for path in tree.paths],\n                [\n                    [\"AWS::StepFunctions::StateMachine\", \"AWS::Lambda\"],\n                    [\"AWS::StepFunctions::StateMachine\", \"AWS::Lambda\"],\n                    [\"AWS::StepFunctions::StateMachine\", \"AWS::SNS\"],\n                ]\n            )\n\n        self.assertTrue(self.iatk.retry_get_trace_tree_until(\n            tracing_header=self.tracing_header,\n            assertion_fn=assertion,\n            timeout_seconds=20,\n        ))\n</code></pre> <p>To run the test code:</p> <pre><code>pytest tests/python/test_example_03.py\n</code></pre>"}]}